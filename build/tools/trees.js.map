{"version":3,"sources":["../../src/tools/trees.js"],"names":["array","tree","t","prop","flatten","flattened","fifo","length","pop","Array","notIn","filter","item","map","copy","filterFun","recurse","list","forEach","filterMap","finalMap","Map","childMap","size","set","perform","elt","cb","path","reverse","p","idx","add","parent","remove","_","i","check","visit","visitor","child","push","unwrapTree","unwrapCheck","Promise","all","children","resolve","then"],"mappings":";;;;AAEA,SAASA,KAAT,QAAsB,UAAtB;;AAEA;;;AAcA,OAAO,IAAMC,OAAO,SAAPA,IAAO,CAAeC,CAAf,EAA0BC,IAA1B;AAAA,WAA6D;AAC7E;;;;AAIAC,iBAAS,mBAAM;AACX,gBAAIC,YAAqB,EAAzB;AACA,gBAAIC,OAAkB,CAACJ,CAAD,CAAtB;AACA,mBAAMI,KAAKC,MAAL,GAAc,CAApB,EAAuB;AACnB,oBAAMN,QAAeK,KAAKE,GAAL,EAArB;AACA,oBAAG,EAAEP,iBAAgBQ,KAAlB,CAAH,EACI;AACJJ,yDAAiBL,MAAMK,SAAN,EAAiBK,KAAjB,CAAuBT,KAAvB,CAAjB,sBAAkDA,KAAlD;AACAK,oDAAYA,IAAZ,sBAAqBL,MAAKU,MAAL,CAAY;AAAA,2BAAQC,KAAKT,IAAL,CAAR;AAAA,iBAAZ,EAAgCU,GAAhC,CAAoC;AAAA,2BAAQD,KAAKT,IAAL,CAAR;AAAA,iBAApC,CAArB;AACH;;AAED,mBAAOE,SAAP;AACH,SAjB4E;AAkB7E;;;;;AAKAM,gBAAQ,2BAAa;AACjB,gBAAMG,OAAOZ,EAAES,MAAF,CAASI,SAAT,CAAb;AACA,gBAAMC,UAAU,SAAVA,OAAU,OAAQ;AACpBC,qBAAKC,OAAL,CAAa,gBAAQ;AACjB,wBAAGN,KAAKT,IAAL,KAAcS,KAAKT,IAAL,aAAsBM,KAAvC,EAA8C;AAC1CG,6BAAKT,IAAL,IAAaS,KAAKT,IAAL,EAAWQ,MAAX,CAAkBI,SAAlB,CAAb;AACAC,gCAAQJ,KAAKT,IAAL,CAAR;AACH;AACJ,iBALD;AAMH,aAPD;AAQAa,oBAAQF,IAAR;AACA,mBAAOA,IAAP;AACH,SAnC4E;AAoC7E;;;;;AAKAK,mBAAW,8BAAa;AACpB,gBAAMC,WAAW,IAAIC,GAAJ,EAAjB;;AAEA,gBAAML,UAAU,SAAVA,OAAU,CAACC,IAAD,EAAOJ,GAAP,EAAe;AAC3BI,qBAAKC,OAAL,CAAa,gBAAQ;AACjB,wBAAGN,KAAKT,IAAL,KAAcS,KAAKT,IAAL,aAAsBM,KAAvC,EAA8C;AAC1C,4BAAMa,WAAW,IAAID,GAAJ,EAAjB;AACAL,gCAAQJ,KAAKT,IAAL,CAAR,EAAoBmB,QAApB;AACA,4BAAGA,SAASC,IAAT,GAAgB,CAAnB,EAAsB;AAClBV,gCAAIW,GAAJ,CAAQZ,IAAR,EAAcU,QAAd;AACH,yBAFD,MAEO,IAAGP,UAAUH,IAAV,CAAH,EAAoB;AACvBC,gCAAIW,GAAJ,CAAQZ,IAAR,EAAc,IAAIS,GAAJ,EAAd;AACH;AACJ,qBARD,MAQO,IAAGN,UAAUH,IAAV,CAAH,EAAoB;AACvBC,4BAAIW,GAAJ,CAAQZ,IAAR,EAAc,IAAd;AACH;AACJ,iBAZD;AAaH,aAdD;AAeAI,oBAAQd,CAAR,EAAWkB,QAAX;AACA,mBAAOA,QAAP;AACH,SA7D4E;AA8D7E;;;;;;;AAOAK,iBAAS,iBAACC,GAAD,EAAMC,EAAN,EAA0B;AAAA,gBAAhBC,IAAgB,uEAAT,IAAS;;AAC/B,gBAAG,CAACA,IAAJ,EAAUA,OAAO3B,KAAKC,CAAL,EAAQC,IAAR,EAAcyB,IAAd,CAAmBF,GAAnB,CAAP;AACV,gBAAGE,gBAAgBnB,KAAnB,EAA0B;AACtBmB,qBAAKC,OAAL,GAAeX,OAAf,CAAuB,UAACY,CAAD,EAAIC,GAAJ,EAAY;AAC/B,wBAAGA,QAAQ,CAAX,EACIJ,GAAGG,CAAH,EADJ,KAGIA,EAAE3B,IAAF,iCAAc2B,EAAE3B,IAAF,CAAd;AACP,iBALD;AAMA,oDAAWD,CAAX;AACH,aARD,MAQO;AACH,uBAAOA,CAAP;AACH;AACJ,SAlF4E;AAmF7E;;;;;;;AAOA8B,aAAK,aAACC,MAAD,EAASP,GAAT;AAAA,gBAAcE,IAAd,uEAAqB,IAArB;AAAA,mBACD3B,KAAKC,CAAL,EAAQC,IAAR,EAAcsB,OAAd,CAAsBQ,MAAtB,EAA8B;AAAA,uBAAKH,EAAE3B,IAAF,iCAAe2B,EAAE3B,IAAF,CAAf,IAAwBuB,GAAxB,EAAL;AAAA,aAA9B,EAAkEE,IAAlE,CADC;AAAA,SA1FwE;AA4F7E;;;;;;;AAOAM,gBAAQ,gBAACD,MAAD,EAASP,GAAT;AAAA,gBAAcE,IAAd,uEAAqB,IAArB;AAAA,mBACJ3B,KAAKC,CAAL,EAAQC,IAAR,EAAcsB,OAAd,CAAsBQ,MAAtB,EAA8B,aAAK;AAC/BH,kBAAE3B,IAAF,IAAU2B,EAAE3B,IAAF,EAAQQ,MAAR,CAAe,aAAK;AAC1B,wBAAG,OAAOe,GAAP,KAAe,UAAlB,EACI,OAAO,CAACA,IAAIS,CAAJ,CAAR;AACJ,2BAAOA,MAAMT,GAAb;AACH,iBAJS,CAAV;AAKH,aAND,EAMGE,IANH,CADI;AAAA,SAnGqE;AA2G7E;;;;;AAKAA,cAAM,mBAAO;AACT,gBAAMZ,UAAU,SAAVA,OAAU,OAAQ;AACpB,oBAAGJ,SAASc,GAAT,IAAgB,OAAOA,GAAP,KAAe,UAAf,IAA6BA,IAAId,IAAJ,CAAhD,EAA2D,OAAO,CAACA,IAAD,CAAP;AAC3D,oBAAG,CAACA,KAAKT,IAAL,CAAJ,EAAgB,OAAO,KAAP;AAChB,qBAAI,IAAIiC,IAAI,CAAZ,EAAeA,IAAIxB,KAAKT,IAAL,EAAWI,MAA9B,EAAsC6B,GAAtC,EAA2C;AACvC,wBAAMC,QAAQrB,QAAQJ,KAAKT,IAAL,EAAWiC,CAAX,CAAR,CAAd;AACA,wBAAGC,KAAH,EAAU,QAASzB,IAAT,4BAAkByB,KAAlB;AACb;AACD,uBAAO,KAAP;AACH,aARD;AASA,iBAAI,IAAID,IAAI,CAAZ,EAAeA,IAAIlC,EAAEK,MAArB,EAA6B6B,GAA7B,EAAkC;AAC9B,oBAAMC,QAAQrB,QAAQd,EAAEkC,CAAF,CAAR,CAAd;AACA,oBAAGC,KAAH,EAAU,OAAOA,KAAP;AACb;AACD,mBAAO,KAAP;AACH,SA/H4E;AAgI7E;;;;AAIAC,eAAO,wBAAW;AACd,gBAAMhC,OAAiB,CAACJ,CAAD,CAAvB;AACA,mBAAMI,KAAKC,MAAL,GAAc,CAApB,EAAuB;AACnB,oBAAMN,SAAOK,KAAKE,GAAL,EAAb;AACA+B,wBAAQtC,MAAR;AACAA,uBAAKiB,OAAL,CAAa;AAAA,2BAASsB,MAAMrC,IAAN,KAAeqC,MAAMrC,IAAN,aAAuBM,KAAtC,GAClBH,KAAKmC,IAAL,CAAUD,MAAMrC,IAAN,CAAV,CADkB,GAElB,IAFS;AAAA,iBAAb;AAGH;AACJ,SA7I4E;AA8I7E;;;;;AAKAuC,oBAAY;AAAA,gBAACC,WAAD,uEAAgB;AAAA,uBAAK,IAAL;AAAA,aAAhB;AAAA,mBAA+BC,QAAQC,GAAR,CAAY3C,EAAEW,GAAF,CAAM,gBAAQ;AACjE,oBAAG,CAACD,KAAKkC,QAAN,IAAkB,CAACH,YAAY/B,IAAZ,CAAtB,EAAyC,OAAOgC,QAAQG,OAAR,CAAgBnC,IAAhB,CAAP;AACzC,uBAAO,CACH,OAAOA,KAAKkC,QAAZ,KAAyB,UAAzB,GACIlC,KAAKkC,QAAL,GAAgBE,IAAhB,CAAqB;AAAA,2BAAY/C,KAAK6C,QAAL,EAAe3C,IAAf,EAAqBuC,UAArB,CAAgCC,WAAhC,CAAZ;AAAA,iBAArB,CADJ,GAEI1C,KAAKW,KAAKkC,QAAV,EAAoB3C,IAApB,EAA0BuC,UAA1B,CAAqCC,WAArC,CAHD,EAILK,IAJK,CAIA;AAAA,wCACApC,IADA;AAEHkC;AAFG;AAAA,iBAJA,CAAP;AAQH,aAVsD,CAAZ,CAA/B;AAAA;AAnJiE,KAA7D;AAAA,CAAb","file":"trees.js","sourcesContent":["// @flow\n\nimport { array } from \"./arrays\"\n\n// crashes gen-flow-files : type treeMap<T> = Map<T, treeMap<T>>\ntype treeMap<T> = Map<T, *>\ntype treeType<T> = {\n    flatten: () => T[],\n    filter: (T => boolean) => T[],\n    filterMap: (T => boolean) => treeMap<T>,\n    perform: (T, (T) => any, ?T[]) => T[],\n    add: (T, T, ?T[]) => T[],\n    remove: (T, T, ?T[]) => T[],\n    path: (T) => T[] | boolean,\n    visit: (T[] => void) => void,\n    unwrapTree: (T => boolean) => Promise<*>\n}\n\nexport const tree = <Item: Object>(t: Item[], prop: string) : treeType<Item> => ({\n    /**\n     * Flattens the tree into a single array.\n     * @return {Array} A flattened array containing all the tree elements\n     */\n    flatten: () => {\n        let flattened : Item[] = []\n        let fifo : Item[][] = [t]\n        while(fifo.length > 0) {\n            const tree: Item[] = fifo.pop()\n            if(!(tree instanceof Array))\n                continue\n            flattened = [ ...array(flattened).notIn(tree), ...tree ]\n            fifo = [ ...fifo, ...tree.filter(item => item[prop]).map(item => item[prop]) ]\n        }\n\n        return flattened\n    },\n    /**\n     * Filters the tree.\n     * @param  {Function} filterFun Filtering function\n     * @return {Tree}               Clone of the original tree without the filtered elements\n     */\n    filter: filterFun => {\n        const copy = t.filter(filterFun)\n        const recurse = list => {\n            list.forEach(item => {\n                if(item[prop] && item[prop] instanceof Array) {\n                    item[prop] = item[prop].filter(filterFun)\n                    recurse(item[prop])\n                }\n            })\n        }\n        recurse(copy)\n        return copy\n    },\n    /**\n     * Filters the tree and returns a Map representing the filtered tree.\n     * @param  {Function} filterFun Filtering function\n     * @return {Map}                A Map representation of the filtered tree\n     */\n    filterMap: filterFun => {\n        const finalMap = new Map()\n\n        const recurse = (list, map) => {\n            list.forEach(item => {\n                if(item[prop] && item[prop] instanceof Array) {\n                    const childMap = new Map()\n                    recurse(item[prop], childMap)\n                    if(childMap.size > 0) {\n                        map.set(item, childMap)\n                    } else if(filterFun(item)) {\n                        map.set(item, new Map())\n                    }\n                } else if(filterFun(item)) {\n                    map.set(item, null)\n                }\n            })\n        }\n        recurse(t, finalMap)\n        return finalMap\n    },\n    /**\n     * Perform an action on a tree element, then update its ancestors references.\n     * @param  {T}          elt           Element on which to perform the action (or matching function)\n     * @param  {Function}   cb            An action callback\n     * @param  {Array}      [path=null]   Ancestors path\n     * @return {Tree}                     An updated tree clone\n     */\n    perform: (elt, cb, path = null) => {\n        if(!path) path = tree(t, prop).path(elt)\n        if(path instanceof Array) {\n            path.reverse().forEach((p, idx) => {\n                if(idx === 0)\n                    cb(p)\n                else\n                    p[prop] = [...p[prop]]\n            })\n            return [...t]\n        } else {\n            return t\n        }\n    },\n    /**\n     * Adds an element and update its ancestors references.\n     * @param {T}       parent        Where to add\n     * @param {T}       elt           What to add (or matching function)\n     * @param {Array}   [path=null]   Ancestors path\n     * @return {Tree}                 An updated tree clone\n     */\n    add: (parent, elt, path = null) =>\n        tree(t, prop).perform(parent, p => p[prop] = [ ...p[prop], elt ], path),\n    /**\n     * Removes an element and update its ancestors references.\n     * @param  {T}      parent      Where to remove\n     * @param  {T}      elt         What to remove (or matching function)\n     * @param  {Array}  [path=null] Ancestors path\n     * @return {Tree}               An updated tree clone\n     */\n    remove: (parent, elt, path = null) =>\n        tree(t, prop).perform(parent, p => {\n            p[prop] = p[prop].filter(_ => {\n                if(typeof elt === \"function\")\n                    return !elt(_)\n                return _ !== elt\n            })\n        }, path),\n    /**\n     * Retrieves all ancestors of an element (or returns false).\n     * @param  {T}      elt Element to search for (or matching function)\n     * @return {Array}      Ancestors path\n     */\n    path: elt => {\n        const recurse = item => {\n            if(item === elt || typeof elt === \"function\" && elt(item)) return [item]\n            if(!item[prop]) return false\n            for(let i = 0; i < item[prop].length; i++) {\n                const check = recurse(item[prop][i])\n                if(check) return [ item, ...check ]\n            }\n            return false\n        }\n        for(let i = 0; i < t.length; i++) {\n            const check = recurse(t[i])\n            if(check) return check\n        }\n        return false\n    },\n    /**\n     * Visits each node of the tree and performs an action.\n     * @param  {Function} visitor Action to perform.\n     */\n    visit: visitor => {\n        const fifo: Item[][] = [t]\n        while(fifo.length > 0) {\n            const tree = fifo.pop()\n            visitor(tree)\n            tree.forEach(child => child[prop] && child[prop] instanceof Array ?\n                fifo.push(child[prop]) :\n                null)\n        }\n    },\n    /**\n     * Resolves asynchronous nodes of the tree (Promises).\n     * @param {Function} unwrapCheck Allows to skip Promises you don't want to unwrap\n     * @return {Promise}\n    */\n    unwrapTree: (unwrapCheck = (_ => true)) => Promise.all(t.map(item => {\n        if(!item.children || !unwrapCheck(item)) return Promise.resolve(item)\n        return (\n            typeof item.children === \"function\" ?\n                item.children().then(children => tree(children, prop).unwrapTree(unwrapCheck)) :\n                tree(item.children, prop).unwrapTree(unwrapCheck)\n        ).then(children => ({\n            ...item,\n            children\n        }))\n    }))\n})\n"]}